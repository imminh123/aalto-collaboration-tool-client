import React, { useCallback, useEffect, useState } from 'react';
import './ChatInput.css'; // Create and import CSS for ChatInput
import { AiOutlineSend } from "react-icons/ai";
import useWebSocket, { ReadyState } from 'react-use-websocket';
import { useSelector, useDispatch } from 'react-redux';
import { setMessages, setMessagesHistory } from '../../../redux/chatReducer';
import secureStorage from 'react-secure-storage';
import { decryptMessage, encryptData, encryptMessage, generateAESKey } from '../../../helpers/cryptography';
import { v4 as uuidv4 } from 'uuid';
import { FileUploader } from "react-drag-drop-files";
import { get } from 'http';
import { setOnlineUsers } from '../../../redux/friendsReducer';
import { setChannelAfterDelete, setChannelHistory, setNewChannelAction } from '../../../redux/channelReducer';
import { useWebSocketContext } from '../../../hooks';

const ChatInput = () => {
  const [input, setInput] = useState('');
  const dispatch = useDispatch();
  const userId = useSelector((state:any) => state.login.user_id);
  const users = useSelector((state: any) => state.users.users);
  const userName = useSelector((state:any) => state.login.username);
  const chatMode = useSelector((state:any) => state.channel.mode);
  const channel = useSelector((state:any) => state.channel.channel);
  const receiverName = useSelector((state:any) => state.channel.directUserName);
  const receiverId = useSelector((state:any) => state.channel.directUserId);
  const receiverPK = useSelector((state:any) => state.channel.directUserPK);
  const newChannelAction = useSelector((state:any) => state.channel.newChannelAction);

  // const socketUrl = `ws://localhost:8000/ws/${userId}`;
  const [file, setFile] = useState(null);
  const fileTypes = ["JPEG", "PNG", "GIF", "PDF"];
  const webSocketContext:any = useWebSocketContext();
  const { sendMessage, lastMessage, readyState, getWebSocket } = webSocketContext;
  
  const handleFile = (file:any) => {
    file[0].sender = userId;
    setFile(file);
  };


  const sendTextMessage = useCallback(async (userInput: string) => {
    if(file !== null){
      sendMessage(JSON.stringify({
        sender: userId,
        receiverId: receiverId,
        receiverName: receiverName,
        channel: channel,
        fileName: (file[0] as any).name,
        messageType: 2, //MessageType 1 for sending text, 2 for sending file
        chatMode: 2,
      }));
      sendMessage(file[0]);
    }
    else {
      const now = new Date();
      if(chatMode === 1) {
        // This is for DirectMessages
        // It would be quite similar with channels as well
        let keyExists = false;
        if(!secureStorage.getItem(`dm_${userId}:${receiverId}`)) {
          // Generate key and send in the message encrypted
          secureStorage.setItem(`dm_${userId}:${receiverId}`, await generateAESKey());
        } else {
          keyExists = true;
        }
  
        const symmetricKey: any = secureStorage.getItem(`dm_${userId}:${receiverId}`) as string;
        let message = {
          messageId: uuidv4(),
          senderId: userId,
          senderName: userName,
          content: await encryptMessage(userInput, symmetricKey), // Encrypt the symmetric key with reciever's PK
          channel: channel,
          timestamp: Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 
          now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds()),
          receiverName: receiverName,
          receiverId: receiverId,
          chatMode: chatMode, 
          messageType: 1,  // MessageType 1 for sending text, 2 for sending file
        };
  
        if(!keyExists) {
          // @ts-ignore
          message.aesKey = await encryptData(symmetricKey, receiverPK);
        }
        sendMessage(JSON.stringify(message))
      } else if (chatMode === 2) {
        // The key will be always existent
        // because a message will be generated by the channel
        // which is going to be always loaded before getting the
        // chance to send something
        const symmetricKey: any = secureStorage.getItem(`ch_${channel.channelId}`) as string;
        let message = {
          messageId: uuidv4(),
          senderId: userId,
          senderName: userName,
          content: await encryptMessage(userInput, symmetricKey), // Encrypt the symmetric key with reciever's PK
          channel: channel.channelId,
          timestamp: Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 
          now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds()),
          chatMode: chatMode, 
          messageType: 1,  // MessageType 1 for sending text, 2 for sending file
        };
        sendMessage(JSON.stringify(message))
        // let keyExists = false;
        // if(!secureStorage.getItem(`${channelName}_key`)) {
        //   // Decrypt the channel key from the appropriate message
        //   // secureStorage.setItem(`dm_${userId}:${receiverId}`, await generateAESKey());
        // } else {
        //   keyExists = true;
        // }
      }
    }
  }, [sendMessage,channel, file, receiverName, receiverId, chatMode]);

  const handleEnter = async (e: React.KeyboardEvent<HTMLInputElement>) => {
    if(e.key === 'Enter'){
      sendTextMessage(input);
      setInput('');
    }
  }

  const handleSendMessage = async () => {
    sendTextMessage(input);
    setInput('');
  }

  const handleSendFile = () => {
      sendTextMessage("");
      setFile(null);
  }

  function filterUsersByUserIDs(items: any, uuidsToFilterBy: any): any {
    // @ts-ignore
    return items.filter(item => uuidsToFilterBy.includes(item.user_id));
  }
  
  // @ts-ignore
  const encryptSymmetricKeysAndWelcomMessageForUsers = async (allUsers, newChannelDetail, key) => {
    let usersToEncryptFor = filterUsersByUserIDs(allUsers, newChannelDetail.channelMembers);
    // console.log(usersToEncryptFor);
    let encryptedKeys = [];
    for(let i = 0; i < usersToEncryptFor.length; i++) {
      encryptedKeys.push({
        userId: usersToEncryptFor[i].user_id,
        enryptedKey: await encryptData(key, usersToEncryptFor[i].public_key)
      });
    }
    // console.log(secureStorage.getItem(`ch_${newChannelDetail.channelId}`) as string);
    const message = {
      messageId: uuidv4(),
      senderId: newChannelAction.channelId,
      senderName: newChannelAction.channelName,
      content: await encryptMessage("Tervetuloa!", secureStorage.getItem(`ch_${newChannelDetail.channelId}`) as string), // Encrypt the symmetric key with reciever's PK
      channel: newChannelDetail.channelId,
      keys: encryptedKeys,
      // receiverName: receiverName,
      // receiverId: receiverId,
      chatMode: 2, 
      messageType: 1,  // MessageType 1 for sending text, 2 for sending file
    };
    return message;
  };

  useEffect(() => {
    if(!!newChannelAction){
      if(newChannelAction.channelAction === 'add'){
        sendMessage(JSON.stringify({
          newChannel: newChannelAction,
          messageType: 4
        }) as any);

        // sendMessage()
        encryptSymmetricKeysAndWelcomMessageForUsers(users, newChannelAction, secureStorage.getItem(`ch_${newChannelAction.channelId}`) as string).then((data) => {
          console.log(data);
          sendMessage(JSON.stringify(data));
        });
        // console.log(encryptSymmetricKeysAndWelcomMessageForUsers(users, newChannelAction.channelMembers, "123"));
        console.log("This is the channel: " + JSON.stringify(newChannelAction))
      }
      else if(newChannelAction.channelAction === 'delete'){
        sendMessage(JSON.stringify({
          deleteChannel: newChannelAction,
          messageType: 5
        }) as any);
      }
    }
    dispatch(setNewChannelAction(null));
  },[newChannelAction])

  useEffect(() => {
    if(!!lastMessage?.data && !!lastMessage && (lastMessage?.data instanceof ArrayBuffer || lastMessage?.data instanceof Blob)){
      const convertedPdfFile = new File([(lastMessage as any)?.data], "tmp.pdf", { type: "application/pdf" });
      let blob = new Blob([convertedPdfFile], { type: convertedPdfFile.type });
      let url = URL.createObjectURL(blob);
      let a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = convertedPdfFile.name;
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      document.body.removeChild(a);
      setFile(null);
    }
    else if(typeof lastMessage?.data === 'string'){
      let messageObject = JSON.parse(lastMessage?.data);
      if (messageObject.loginType === 0){
        // loginType = 0: rerender online user list
        dispatch(setOnlineUsers(messageObject.onlineUserList))
      }
      else if (messageObject.loginType === 1)
      {
        // loginType = 1: load all messages history and channel history to new login user
        dispatch(setMessagesHistory(messageObject.messagesHistory))
        dispatch(setChannelHistory(messageObject.channelHistory))
      }
      // loginType = 2: load channel history to new login user
      else if (messageObject.loginType === 2){
        dispatch(setChannelHistory(messageObject.channelHistory))
      }
      else if(messageObject.loginType === 3){
        dispatch(setChannelAfterDelete(messageObject.deletedChannel));
      }
      else{
        dispatch(setMessages(lastMessage?.data));
      }
      
    }
  }, [lastMessage?.data]);



  return (
    <div className="chat_section">
      <div className='file_input'>
        <FileUploader
            multiple={true}
            handleChange={handleFile}
            name="file"
            types={fileTypes}
            className='file_input_field'
          />
          {file && <button className='send_button' 
          onClick={handleSendFile}
          >Up Load File</button>}
      </div>
      <div className='chat_input'>
        <input
          className='chat_input_field'
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleEnter}
          placeholder="Aa"
        />
        <button className='send_button' onClick={handleSendMessage}><AiOutlineSend/></button>
      </div>
    </div>
  );
};

export default ChatInput;
